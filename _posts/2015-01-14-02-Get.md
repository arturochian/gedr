---
title: "02 - Get"
author: Jeffrey W. Hollister
layout: post_page
---



The second lesson is going to start to lay the foundation for working with data in R.  We will cover some of the very basics of R first, then move on to how you get data into R and how you work with some of the basic data structures.  Lastly, we will cover some ways to find relevant data and pull it directly into R.

##Quick Links to Exercises and R code
- [Lesson 2 R Code](http://jwhollister.com/gedr/rmd_posts/2015-01-14-02-Get.R): All the code from this post in an R Script.
- [Exercise 1](#exercise-1): Introduction to the console and basic functions

##Lesson Goals
- Understand workflow basics
- Learn R concepts such as assignment and operators
- Learn some useful R functions
- Understand the basic data structures and data types
- Be able to read data into R from a variety of sources

##More basics
Before we jump into details on data in R we need to introduce a few of the basics about working in the console, working via scripts, and workspaces/projects.  We will also start working with some simple, yet important R functions.

###Workflow
Being thoughtful about workflow from the beginning of a project is something that gets overlooked a lot, but a little up-front effort can provide a big benefit.  For our purposes we are going to make use of RStudio projects and script **EVERYTHING**.  The console has its utility and we will use it plenty, especially when we are first figuring out how to use commands.  But beyond that, we will store all of our work in a script.  The basic workflow I am going to advocate is:

1. Use a single project for this workshop (we created that in Lesson 1: Exercise 1).
2. Start everything in a script and use copy/paste or the RStudio tools to send to the console.
3. Use a new script for each lesson.
4. Comment ruthlessly.
5. Don't save .RData files or workspace history.  The script should recreate whatever you need.

This, of course, is not the only way you can strucutre a workflow, but I think it should be a good starting point for this workshop and one you can adapt to you own work afterwards.  And to provide a little motiviation, the more you utilize scripts, the more reproducible you work is, the more likely you will be able to recall what you did 3 months from now (your future self will thank you), and the easier it will be to transition your work from scripts to functions and, ultimately, to R packages.

###Working in the Console
As I mentioned above, the conosle and using R interactively is very powerful.  We will do this quite a bit.  Let's spend a little time playing around in the console and learn a few new functions.

R can be used as a caculator and a way to compare values.  Some examples of the basic operators:


{% highlight r %}
#A really powerful calculator!
1+1 #Add
{% endhighlight %}



{% highlight text %}
## [1] 2
{% endhighlight %}



{% highlight r %}
10-4 #Subtract
{% endhighlight %}



{% highlight text %}
## [1] 6
{% endhighlight %}



{% highlight r %}
3*2 #Multiply
{% endhighlight %}



{% highlight text %}
## [1] 6
{% endhighlight %}



{% highlight r %}
3^3 #Exponents
{% endhighlight %}



{% highlight text %}
## [1] 27
{% endhighlight %}



{% highlight r %}
100/10 #Divide
{% endhighlight %}



{% highlight text %}
## [1] 10
{% endhighlight %}



{% highlight r %}
5%%2 #Modulus
{% endhighlight %}



{% highlight text %}
## [1] 1
{% endhighlight %}



{% highlight r %}
5>2 #Greater than
{% endhighlight %}



{% highlight text %}
## [1] TRUE
{% endhighlight %}



{% highlight r %}
4<5 #Less than
{% endhighlight %}



{% highlight text %}
## [1] TRUE
{% endhighlight %}



{% highlight r %}
5<=5 #Less than or equal
{% endhighlight %}



{% highlight text %}
## [1] TRUE
{% endhighlight %}



{% highlight r %}
8>=2 #Greater than or equal
{% endhighlight %}



{% highlight text %}
## [1] TRUE
{% endhighlight %}

That's neat, but so what...  

Well, it could be interesting to do something with those values and save them for re-use.  We can do that with objects (everything in R is an object) and use the assignment operator, `<-`.  Know that object names cannot start with a number, contain spaces, or (most) special characters.  Underscore and periods are allowed.


{% highlight r %}
#Numeric assignment
x<-5
x
{% endhighlight %}



{% highlight text %}
## [1] 5
{% endhighlight %}



{% highlight r %}
y<-x+1
y
{% endhighlight %}



{% highlight text %}
## [1] 6
{% endhighlight %}



{% highlight r %}
z<-x+y
z
{% endhighlight %}



{% highlight text %}
## [1] 11
{% endhighlight %}



{% highlight r %}
#Character
a<-"Bob"
a
{% endhighlight %}



{% highlight text %}
## [1] "Bob"
{% endhighlight %}



{% highlight r %}
b<-"Sue"
b
{% endhighlight %}



{% highlight text %}
## [1] "Sue"
{% endhighlight %}

Now that we have a little experience working in the console and creating objects with `<-`, we might want to be able to do some additional things to navigate around, look at these objects etc.

Some functions that you might fund useful for working in with your R workspace:


{% highlight r %}
#List all objects in current workspace
ls() 
{% endhighlight %}



{% highlight text %}
## [1] "a"       "b"       "rmdfile" "x"       "y"       "z"
{% endhighlight %}



{% highlight r %}
ls(pattern="a")
{% endhighlight %}



{% highlight text %}
## [1] "a"
{% endhighlight %}



{% highlight r %}
#Remove an object
rm(x)

#Save your workspace
#Saves the whole thing to a file called lesson2.RData
save.image("lesson2.RData") 
#Saves just the a and y objects to a file called lesson2_ay.RData
save(a,y,file="lesson2_ay.RData")
{% endhighlight %}

This is probably a good spot to bring up quotes vs no quotes around arguments in a function.  This is a very common stumbling block.  The general rule is that no quotes are used only when referring to an object that currently exists.  Quotes are used in all other cases.  For instance in `save(a,y,file="lesson2_ay.RData")` the objects `a` and `y` are not quoted becuase they are objects in the workspace.  `file` is an argument of save and arguments are never quoted.  We quote the name of the file "lesson2_ay.RData" becuase it is not an R object but the name of a file to be created.  

You will likely still have some issues with this.  My recomendataion is to think about if it is an object in your R workspace or not.  If so, no quotes!

Next thing you might want to do is navigate around your files and directories.


{% highlight r %}
#See the current directory
getwd()
{% endhighlight %}



{% highlight text %}
## [1] "/home/jhollist/projects/gedr/rmd_posts"
{% endhighlight %}



{% highlight r %}
#Create a directory
dir.create("temp")
{% endhighlight %}



{% highlight text %}
## Warning in dir.create("temp"): 'temp' already exists
{% endhighlight %}



{% highlight r %}
#Change the directory
setwd("temp")

#List files and directories
list.files()
{% endhighlight %}



{% highlight text %}
## character(0)
{% endhighlight %}



{% highlight r %}
list.files("..")
{% endhighlight %}



{% highlight text %}
##  [1] "2014-11-12-Proposed-Outline.md"       
##  [2] "2014-11-12-Proposed-Outline.R"        
##  [3] "2014-11-12-Proposed-Outline.Rmd"      
##  [4] "2015-01-14-00-Before-The-Workshop.md" 
##  [5] "2015-01-14-00-Before-The-Workshop.Rmd"
##  [6] "2015-01-14-01-Introduction.md"        
##  [7] "2015-01-14-01-Introduction.R"         
##  [8] "2015-01-14-01-Introduction.Rmd"       
##  [9] "2015-01-14-02-Get.md"                 
## [10] "2015-01-14-02-Get.R"                  
## [11] "2015-01-14-02-Get.Rmd"                
## [12] "2015-01-14-03-Clean.md"               
## [13] "2015-01-14-03-Clean.Rmd"              
## [14] "2015-01-14-04-Clean.md"               
## [15] "2015-01-14-04-Clean.Rmd"              
## [16] "2015-01-14-05-Explore.md"             
## [17] "2015-01-14-05-Explore.Rmd"            
## [18] "2015-01-15-06-Analyze.md"             
## [19] "2015-01-15-06-Analyze.Rmd"            
## [20] "2015-01-15-07-Visualize.md"           
## [21] "2015-01-15-07-Visualize.Rmd"          
## [22] "2015-01-15-08-Visualize.md"           
## [23] "2015-01-15-08-Visualize.Rmd"          
## [24] "2015-01-15-09-Advanced-Topics.md"     
## [25] "2015-01-15-09-Advanced-Topics.Rmd"    
## [26] "cache"                                
## [27] "knit_it.R"                            
## [28] "lesson2_ay.RData"                     
## [29] "lesson2.RData"                        
## [30] "Makefile"                             
## [31] "Makefile~"                            
## [32] "temp"                                 
## [33] "x.txt"
{% endhighlight %}



{% highlight r %}
list.dirs("..")
{% endhighlight %}



{% highlight text %}
## [1] ".."       "../cache" "../temp"
{% endhighlight %}

##Exercise 1
For this first excercise I am actually going to ignore my workflow advice from above.  We are still in explore mode and saving this as a script doesn't yet make a whole lot of sense. Remember to use the green stickies when you have completed, and red stickies if you are running into problems. So, for this exercise:

1. Create two objects named `number1` and `number2` and give them the values of 25 and 4, respectively 
2. Create two more objects named `string1` and `string2`, give them any character string that you would like. 
3. Now using `number1`,`number2`, and the power of math create an object called `number3` that equals 100.
4. Create two more objects whose value is of your choosing
5. List the objects in your workspace
6. Remove `string2`
6. List your working directory
7. List the files in your working directory
8. Make sure your working directory is "gedr_workshop", if not use `setwd()` to get there.
9. Create a new directory called "R"
10. Try to add `string1` and `number1`.  What happens?  

So the last question in exercise 1 was a bit of a contrived way to segue into data types and structures.  So with that last bit, what did we ask R to do?  Why did it respond the way it did?  

In short it has a lot to do with data types.  Let's learn some more

##Data types and data structures in R
*Borrowed liberally from Jenny Bryan's [course materials on r](http://www.stat.ubc.ca/~jenny/STAT545A/quick-index.html) and Karthik Ram's [material from the Canberra Software Carpentry R Bootcamp](https://github.com/swcarpentry/2013-10-09-canberra).  Anything good is because of Jenny and Karthik.  Mistakes are all mine.*

Remember that everything in R is an object.  With regards to data, those objects have some specific characteristics that help R (and us) know what kind of data we are dealing with and what kind of operations can be done on that data.  This stuff may be a bit dry, but a basic understanding will help as so much of what we do with analysis has to do with the organization and type of data we have. First, lets discuss the atomic data types.

###Data Types
There are 5 basic atomic classes: character, numeric (real or decimal), integer, logical, and complex.

| Example | Type |
| ------- | ---- |
| "a", "swc" | character |
| 2, 15.5 | numeric | 
| 2 (usually add a `L` at end to denote integer)      | integer |
| `TRUE`, `FALSE` | logical |
| 1+4i | complex | 

In this workshop we will deal almost exclusively with three (and these are, in my experience, by far the most common): character, numeric, and logical.  There are also some useful commands to explore these data types and get some basic information about them.


{% highlight r %}
typeof()  # what is it?
length()  # how long is it? What about two dimensional objects?
attributes()  # does it have any metadata?
{% endhighlight %}

###Data Structures


R also has many data structures. These include

* vector
* list
* matrix
* data frame
* factors
* tables


### Vectors
A vector is the most common and basic data structure in `R` and is pretty much the workhorse of R. Vectors can be of two types:

* atomic vectors
* lists

**Atomic Vectors**
A vector can be a vector of characters, logical, integers or numeric.

Create an empty vector with `vector()`



{% highlight r %}
x <- vector()
x
{% endhighlight %}



{% highlight text %}
## logical(0)
{% endhighlight %}



{% highlight r %}
# with a pre-defined length
x <- vector(length = 10)
x
{% endhighlight %}



{% highlight text %}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
{% endhighlight %}



{% highlight r %}
# with a length and type
vector("character", length = 10)
{% endhighlight %}



{% highlight text %}
##  [1] "" "" "" "" "" "" "" "" "" ""
{% endhighlight %}



{% highlight r %}
vector("numeric", length = 10)
{% endhighlight %}



{% highlight text %}
##  [1] 0 0 0 0 0 0 0 0 0 0
{% endhighlight %}



{% highlight r %}
vector("integer", length = 10)
{% endhighlight %}



{% highlight text %}
##  [1] 0 0 0 0 0 0 0 0 0 0
{% endhighlight %}



{% highlight r %}
vector("logical", length = 10)
{% endhighlight %}



{% highlight text %}
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
{% endhighlight %}

The general pattern is `vector(class of object, length)`.  You can also create vectors by concactenating them using the `c()` function.

Various examples:



{% highlight r %}
x <- c(1, 2, 3)
{% endhighlight %}

x is a numeric vector. These are the most common kind. They are numeric objects and are treated as double precision real numbers. To explicitly create integers, add a `L` at the end.



{% highlight r %}
x1 <- c(1L, 2L, 3L)
{% endhighlight %}


You can also have logical vectors. 



{% highlight r %}
y <- c(TRUE, TRUE, FALSE, FALSE)
{% endhighlight %}


Finally you can have character vectors:



{% highlight r %}
z <- c("Alec", "Dan", "Rob", "Karthik")
{% endhighlight %}


**Examine your vector**  



{% highlight r %}
typeof(z)
{% endhighlight %}



{% highlight text %}
## [1] "character"
{% endhighlight %}



{% highlight r %}
length(z)
{% endhighlight %}



{% highlight text %}
## [1] 4
{% endhighlight %}



{% highlight r %}
class(z)
{% endhighlight %}



{% highlight text %}
## [1] "character"
{% endhighlight %}



{% highlight r %}
str(z)
{% endhighlight %}



{% highlight text %}
##  chr [1:4] "Alec" "Dan" "Rob" "Karthik"
{% endhighlight %}


Question: Do you see a property that's common to all these vectors above?

**Add elements**



{% highlight r %}
z <- c(z, "Annette")
z
{% endhighlight %}



{% highlight text %}
## [1] "Alec"    "Dan"     "Rob"     "Karthik" "Annette"
{% endhighlight %}


More examples of vectors



{% highlight r %}
x <- c(0.5, 0.7)
x <- c(TRUE, FALSE)
x <- c(T, F)
x <- c("a", "b", "c", "d", "e")
x <- 9:100
x <- c(i + 0, 2 + 4)
{% endhighlight %}



{% highlight text %}
## Error in eval(expr, envir, enclos): object 'i' not found
{% endhighlight %}


You can also create vectors as sequence of numbers



{% highlight r %}
series <- 1:10
seq(10)
{% endhighlight %}



{% highlight text %}
##  [1]  1  2  3  4  5  6  7  8  9 10
{% endhighlight %}



{% highlight r %}
seq(1, 10, by = 0.1)
{% endhighlight %}



{% highlight text %}
##  [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3
## [15]  2.4  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7
## [29]  3.8  3.9  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1
## [43]  5.2  5.3  5.4  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5
## [57]  6.6  6.7  6.8  6.9  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9
## [71]  8.0  8.1  8.2  8.3  8.4  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3
## [85]  9.4  9.5  9.6  9.7  9.8  9.9 10.0
{% endhighlight %}


**Other objects**

`Inf` is infinity. You can have positive or negative infinity.



{% highlight r %}
1/0
{% endhighlight %}



{% highlight text %}
## [1] Inf
{% endhighlight %}



{% highlight r %}
# [1] Inf
1/Inf
{% endhighlight %}



{% highlight text %}
## [1] 0
{% endhighlight %}



{% highlight r %}
# [1] 0
{% endhighlight %}



`NaN` means Not a number. it's an undefined value.



{% highlight r %}
0/0
{% endhighlight %}



{% highlight text %}
## [1] NaN
{% endhighlight %}



{% highlight r %}
NaN.
{% endhighlight %}



{% highlight text %}
## Error in eval(expr, envir, enclos): object 'NaN.' not found
{% endhighlight %}


Each object has an attribute. Attribues can be part of an object of R. These include 

* names
* dimnames
* length
* class
* attributes (contain metadata)

For a vector, `length(vector_name)` is just the total number of elements.


**What happens when you mix types?**

R will create a resulting vector that is the least common denominator. The coercion will move towards the one that's easiest to coerce to.

**Guess what the following do without running them first**



{% highlight r %}
xx <- c(1.7, "a")
xx <- c(TRUE, 2)
xx <- c("a", TRUE)
{% endhighlight %}


This is called implicit coercion.  You can also coerce vectors explicitly using the `as.<class_name>`. Example



{% highlight r %}
as.numeric()
{% endhighlight %}



{% highlight text %}
## numeric(0)
{% endhighlight %}



{% highlight r %}
as.character()
{% endhighlight %}



{% highlight text %}
## character(0)
{% endhighlight %}



When you coerce an existing numeric vector with `as.numeric()`, it does nothing.



{% highlight r %}
x <- 0:6
as.numeric(x)
{% endhighlight %}



{% highlight text %}
## [1] 0 1 2 3 4 5 6
{% endhighlight %}



{% highlight r %}
as.logical(x)
{% endhighlight %}



{% highlight text %}
## [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
{% endhighlight %}



{% highlight r %}
as.character(x)
{% endhighlight %}



{% highlight text %}
## [1] "0" "1" "2" "3" "4" "5" "6"
{% endhighlight %}



{% highlight r %}
as.complex(x)
{% endhighlight %}



{% highlight text %}
## [1] 0+0i 1+0i 2+0i 3+0i 4+0i 5+0i 6+0i
{% endhighlight %}


Sometimes coercions, especially nonsensical ones wont work.



{% highlight r %}
x <- c("a", "b", "c")
as.numeric(x)
{% endhighlight %}



{% highlight text %}
## Warning: NAs introduced by coercion
{% endhighlight %}



{% highlight text %}
## [1] NA NA NA
{% endhighlight %}



{% highlight r %}
as.logical(x)
{% endhighlight %}



{% highlight text %}
## [1] NA NA NA
{% endhighlight %}



{% highlight r %}
# both don't work
{% endhighlight %}


**Sometimes there is implicit conversion**


{% highlight r %}
1 < "2"
{% endhighlight %}



{% highlight text %}
## [1] TRUE
{% endhighlight %}



{% highlight r %}
"1" > 2
{% endhighlight %}



{% highlight text %}
## [1] FALSE
{% endhighlight %}


### Matrix

Matrices are a special vector in R. They are not a separate class of object but simply a vector but now with dimensions added on to it. Matrices have rows and columns. 



{% highlight r %}
m <- matrix(nrow = 2, ncol = 2)
m
{% endhighlight %}



{% highlight text %}
##      [,1] [,2]
## [1,]   NA   NA
## [2,]   NA   NA
{% endhighlight %}



{% highlight r %}
dim(m)
{% endhighlight %}



{% highlight text %}
## [1] 2 2
{% endhighlight %}



{% highlight r %}
# same as
attributes(m)
{% endhighlight %}



{% highlight text %}
## $dim
## [1] 2 2
{% endhighlight %}


Matrices are constructed columnwise. 



{% highlight r %}
m <- matrix(1:6, nrow = 2, ncol = 3)
{% endhighlight %}


Other ways to construct a matrix



{% highlight r %}
m <- 1:10
dim(m) <- c(2, 5)
{% endhighlight %}


This takes a vector and transform into a matrix with 2 rows and 5 columns.


Another way is to bind columns or rows using `cbind()` and `rbind()`.



{% highlight r %}
x <- 1:3
y <- 10:12
cbind(x, y)
{% endhighlight %}



{% highlight text %}
##      x  y
## [1,] 1 10
## [2,] 2 11
## [3,] 3 12
{% endhighlight %}



{% highlight r %}
# or
rbind(x, y)
{% endhighlight %}



{% highlight text %}
##   [,1] [,2] [,3]
## x    1    2    3
## y   10   11   12
{% endhighlight %}


---

### List

In R lists act as containers. Unlike atomic vectors, its contents are not restricted to a single mode and can encompass any data type. Lists are sometimes called recursive vectors, because a list can contain other lists. This makes them fundamentally different from atomic vectors. 

List is a special vector. Each element can be a different class.

Create lists using `list` or coerce other objects using `as.list()`




{% highlight r %}
x <- list(1, "a", TRUE, 1 + 4)
{% endhighlight %}




{% highlight r %}
x <- 1:10
x <- as.list(x)
length(x)
{% endhighlight %}



{% highlight text %}
## [1] 10
{% endhighlight %}


What is the class of `x[1]`?  
how about `x[[1]]`?



{% highlight r %}
xlist <- list(a = "Karthik Ram", b = 1:10, data = head(iris))
{% endhighlight %}


what is the length of this object?
what about its structure?

List can contain as many lists nested inside.



{% highlight r %}
temp <- list(list(list(list())))
temp
{% endhighlight %}



{% highlight text %}
## [[1]]
## [[1]][[1]]
## [[1]][[1]][[1]]
## list()
{% endhighlight %}



{% highlight r %}
is.recursive(temp)
{% endhighlight %}



{% highlight text %}
## [1] TRUE
{% endhighlight %}


Lists are extremely useful inside functions. You can "staple" together lots of different kinds of results into a single object that a function can return.

It doesn't print out like a vector. Prints a new line for each element.

Elements are indexed by double brackets. Single brackets will still return a(nother) list.

---

### Factors

Factors are special vectors that represent categorical data. Factors can be ordered or unordered and are important when for modelling functions such as `lm()` and `glm()` and also in plot methods.

Factors can only contain pre-defined values.

Factors are pretty much integers that have labels on them.  While factors look (and often behave) like character vectors, they are actually integers under the hood, and you need to be careful when treating them like strings. Some string methods will coerce factors to strings, while others will throw an error.

Sometimes factors can be left unordered. Example: male, female

Other times you might want factors to be ordered (or ranked). Example: low, medium, high. 


Underlying it's represented by numbers 1,2,3.


They are better than using simple integer labels because factors are what are called self describing. male and female is more descriptive than 1s and 2s. Helpful when there is no additional metadata.

Which is male? 1 or 2? You wouldn't be able to tell with just integer data. Factors have this information built in.

Factors can be created with `factor()`. Input is a character vector.



{% highlight r %}
x <- factor(c("yes", "no", "no", "yes", "yes"))
x
{% endhighlight %}



{% highlight text %}
## [1] yes no  no  yes yes
## Levels: no yes
{% endhighlight %}


`table(x)` will return a frequency table.

`unclass(x)` strips out the class information.

In modeling functions, importnat to know whta baseline levels is.
This is the first factor but by default the ordering is determined by alphabetical order of words entered. You can change this by speciying the levels.



{% highlight r %}
x <- factor(c("yes", "no", "yes"), levels = c("yes", "no"))
{% endhighlight %}


### Data frame

A data frame is a very important data type in R. It's pretty much the de facto data structure for most tabular data and what we use for statistics.

data frames can have additional attributes such as `rownames()`. This can be useful for annotating data, like subject_id or sample_id. But most of the time they are not used.

e.g. `rownames()`
useful for annotating data. subject names.
other times they are not useful.

* Data frames Usually created by read.csv and read.table.

* Can convert to `matrix` with `data.matrix()`

* Coercion will force and not always what you expect.

* Can also create with `data.frame()` function.


With and data frame, you can do `nrow(df)` and `ncol(df)`
rownames are usually 1..n.

**Combining data frames**



{% highlight r %}
df <- data.frame(id = letters[1:10], x = 1:10, y = rnorm(10))
df
{% endhighlight %}



{% highlight text %}
##    id  x          y
## 1   a  1 -0.3334348
## 2   b  2  0.1964078
## 3   c  3 -0.5858012
## 4   d  4 -0.3160352
## 5   e  5 -1.3722104
## 6   f  6  1.2084459
## 7   g  7 -0.3474941
## 8   h  8  1.7575253
## 9   i  9  0.4876394
## 10  j 10 -0.7755814
{% endhighlight %}


`cbind(df, data.frame(z = 4))`

When you combine column wise, only row numbers need to match. If you are adding a vector, it will get repeated.

**Useful functions**  
`head()` - see first 5 rows
`tail()` - see last 5 rows
`dim()` - see dimensions
`nrow()` - number of rows
`ncol()` - number of columns
`str()` - structure of each column
`names()` - will list column names for a data.frame (or any object really).
`summary()` - summarizes each column in a data frame

A data frame is a special type of list where every element of a list has same length.

See that it is actually a special list:

    > is.list(iris)
    [1] TRUE
    > class(iris)
    [1] "data.frame"
     > 
--

**Naming objects**  

Other R objects can also have names not just true for data.frames. Adding names is helpful since it's useful for readable code and self describing objects.



{% highlight r %}
x <- 1:3
names(x) <- c("karthik", "ram", "rocks")
x
{% endhighlight %}



{% highlight text %}
## karthik     ram   rocks 
##       1       2       3
{% endhighlight %}


Lists can also have names.



{% highlight r %}
x <- as.list(1:10)
names(x) <- letters[seq(x)]
x
{% endhighlight %}



{% highlight text %}
## $a
## [1] 1
## 
## $b
## [1] 2
## 
## $c
## [1] 3
## 
## $d
## [1] 4
## 
## $e
## [1] 5
## 
## $f
## [1] 6
## 
## $g
## [1] 7
## 
## $h
## [1] 8
## 
## $i
## [1] 9
## 
## $j
## [1] 10
{% endhighlight %}


Finally matrices can have names and these are called `dimnames`



{% highlight r %}
m <- matrix(1:4, nrow = 2)
dimnames(m) <- list(c("a", "b"), c("c", "d"))
# first element = rownames second element = colnames
{% endhighlight %}

---


### Missing values

dennoted by `NA` and/or `NaN` for undefined mathematical operations.



{% highlight r %}
is.na()
{% endhighlight %}



{% highlight text %}
## Error in is.na(): 0 arguments passed to 'is.na' which requires 1
{% endhighlight %}



{% highlight r %}
is.nan()
{% endhighlight %}



{% highlight text %}
## Error in is.nan(): 0 arguments passed to 'is.nan' which requires 1
{% endhighlight %}


check for both.

NA values have a class. So you can have both an integer NA and a missing character NA.

Nan is also NA. But not the other way around.



{% highlight r %}
x <- c(1, 2, NA, 4, 5)
is.na(x)  #returns logical. shows third
{% endhighlight %}



{% highlight text %}
## [1] FALSE FALSE  TRUE FALSE FALSE
{% endhighlight %}



{% highlight r %}
is.nan(x)  #none are NaN.
{% endhighlight %}



{% highlight text %}
## [1] FALSE FALSE FALSE FALSE FALSE
{% endhighlight %}

{% highlight r %}
x <- c(1, 2, NA, NaN, 4, 5)
is.na(x)  #shows 2 TRUE.
{% endhighlight %}



{% highlight text %}
## [1] FALSE FALSE  TRUE  TRUE FALSE FALSE
{% endhighlight %}



{% highlight r %}
is.nan(x)  #shows 1 TRUE
{% endhighlight %}



{% highlight text %}
## [1] FALSE FALSE FALSE  TRUE FALSE FALSE
{% endhighlight %}



##Reading data into R

##Exercise 2
